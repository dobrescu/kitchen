---
name: infrastructure-guidelines
description: AWS infrastructure patterns for Kitchen - Lambda (container), API Gateway, ECR, IAM. Use when working with Lambda functions, API routes, ECR repositories, or IAM permissions.
---

# Infrastructure Guidelines

## When this skill should be used

Auto-activates when Claude is:

- Creating or modifying Lambda functions
- Working with API Gateway routes or custom domains
- Setting up ECR repositories
- Configuring IAM roles or policies
- Loading Docker image references

Behavioral rules:

- Container-based Lambdas (not zip files)
- Use image digests for immutable deployments
- HTTP API v2 (not REST API) for cost efficiency
- Least-privilege IAM policies
- Shared utilities for common patterns

---

## 1. Container-based Lambda pattern

**File:** `src/service/lambdas/chef-lambda.ts`

```typescript
import * as lambda from 'aws-cdk-lib/aws-lambda';
import * as ecr from 'aws-cdk-lib/aws-ecr';
import { loadImageReference } from '../../shared/image-reference-loader.js';

export class ChefLambda extends Construct {
	public readonly function: lambda.DockerImageFunction;

	constructor(scope: Construct, id: string, props: ChefLambdaProps) {
		super(scope, id);

		const chefRepo = ecr.Repository.fromRepositoryAttributes(this, 'ChefRepo', {
			repositoryArn: props.repositoryArn,
			repositoryName: props.repositoryName
		});

		this.function = new lambda.DockerImageFunction(this, 'ChefFunction', {
			functionName: 'chef',
			code: lambda.DockerImageCode.fromEcr(chefRepo, {
				tagOrDigest: loadImageReference('chef')
			}),
			memorySize: 512,
			timeout: cdk.Duration.seconds(30),
			environment: {
				OPENAI_API_KEY: ssm.StringParameter.valueForStringParameter(this, props.openAiApiKey),
				S3_COOKBOOKS: props.s3CookbooksBucket,
				DYNAMODB_COOKBOOKS: props.dynamoCookbooksTable,
				PREPPER_URL: props.prepperUrl
			}
		});

		// Grant permissions (see IAM section)
		this.grantPermissions();
	}
}
```

**Key points:**
- Use `DockerImageFunction` for containers
- Load image by digest (not tag) for immutability
- Environment variables from SSM or props
- Memory and timeout appropriate for workload (Chef: 512MB, Prepper: 4096MB)

---

## 2. Image reference loading

**Immutable deployments:** Use SHA256 digests instead of tags.

**File:** `src/shared/image-reference-loader.ts`

```typescript
export const loadImageReference = (repoName: string): string => {
	// 1. Try image-manifest.json (generated by resolve-digests script)
	if (fs.existsSync('image-manifest.json')) {
		const manifest = JSON.parse(fs.readFileSync('image-manifest.json', 'utf-8'));
		if (manifest[repoName]?.digest) {
			return manifest[repoName].digest; // e.g., "sha256:abc123..."
		}
	}

	// 2. Fallback to env var
	const envTag = process.env[`${repoName.toUpperCase()}_IMAGE_TAG`];
	if (envTag) {
		return envTag;
	}

	// 3. Final fallback
	return 'latest';
};
```

**Workflow:**
1. CI/CD runs `scripts/resolve-image-digests.sh` â†’ generates `image-manifest.json`
2. CDK loads digest from manifest
3. Lambda deployed with immutable image reference

**Why:** Prevents unexpected updates when new images are pushed to ECR.

---

## 3. API Gateway HTTP API v2

**File:** `src/service/kitchen-api.ts`

```typescript
import * as apigwv2 from 'aws-cdk-lib/aws-apigatewayv2';
import * as route53 from 'aws-cdk-lib/aws-route53';
import * as acm from 'aws-cdk-lib/aws-certificatemanager';

export class KitchenApi extends Construct {
	public readonly api: apigwv2.HttpApi;

	constructor(scope: Construct, id: string, props: KitchenApiProps) {
		super(scope, id);

		// Custom domain with TLS certificate
		const hostedZone = route53.HostedZone.fromLookup(this, 'HostedZone', {
			domainName: props.hostedZoneName
		});

		const certificate = new acm.Certificate(this, 'Certificate', {
			domainName: props.domainName,
			validation: acm.CertificateValidation.fromDns(hostedZone)
		});

		const domainName = new apigwv2.DomainName(this, 'DomainName', {
			domainName: props.domainName,
			certificate
		});

		// HTTP API v2
		this.api = new apigwv2.HttpApi(this, 'HttpApi', {
			apiName: 'kitchen-api',
			corsPreflight: {
				allowOrigins: ['*'],
				allowMethods: [apigwv2.CorsHttpMethod.GET, apigwv2.CorsHttpMethod.POST],
				allowHeaders: ['*']
			},
			defaultDomainMapping: { domainName }
		});

		// Route53 alias
		new route53.ARecord(this, 'AliasRecord', {
			zone: hostedZone,
			recordName: props.domainName,
			target: route53.RecordTarget.fromAlias(
				new route53_targets.ApiGatewayv2DomainProperties(
					domainName.regionalDomainName,
					domainName.regionalHostedZoneId
				)
			)
		});
	}

	addRoute(path: string, method: apigwv2.HttpMethod, integration: apigwv2.HttpRouteIntegration) {
		new apigwv2.HttpRoute(this, `Route-${method}-${path.replace('/', '')}`, {
			httpApi: this.api,
			routeKey: apigwv2.HttpRouteKey.with(path, method),
			integration
		});
	}
}
```

**Usage:**

```typescript
const api = new KitchenApi(this, 'Api', {
	domainName: 'cook.hautomation.org',
	hostedZoneName: 'hautomation.org'
});

api.addRoute('/fetch', apigwv2.HttpMethod.GET,
	new apigwv2_integrations.HttpLambdaIntegration('PrepperIntegration', prepperLambda.function)
);
```

**Why HTTP API v2:**
- 70% cheaper than REST API
- Simpler configuration
- Built-in CORS support

---

## 4. ECR repositories

**File:** `src/infra/ecr-repositories.ts`

```typescript
import * as ecr from 'aws-cdk-lib/aws-ecr';

export class EcrRepositories extends Construct {
	public readonly chef: ecr.Repository;
	public readonly prepper: ecr.Repository;

	constructor(scope: Construct, id: string) {
		super(scope, id);

		this.chef = new ecr.Repository(this, 'ChefRepository', {
			repositoryName: 'chef',
			imageScanOnPush: false, // Disable for cost savings
			removalPolicy: cdk.RemovalPolicy.DESTROY,
			lifecycleRules: [
				{
					description: 'Keep max 10 images',
					maxImageCount: 10
				},
				{
					description: 'Delete untagged after 1 day',
					tagStatus: ecr.TagStatus.UNTAGGED,
					maxImageAge: cdk.Duration.days(1)
				}
			]
		});

		this.prepper = new ecr.Repository(this, 'PrepperRepository', {
			repositoryName: 'prepper',
			imageScanOnPush: false,
			removalPolicy: cdk.RemovalPolicy.DESTROY,
			lifecycleRules: [
				{
					description: 'Keep max 10 images',
					maxImageCount: 10
				},
				{
					description: 'Delete untagged after 1 day',
					tagStatus: ecr.TagStatus.UNTAGGED,
					maxImageAge: cdk.Duration.days(1)
				}
			]
		});
	}
}
```

**Lifecycle policies:**
- Keep 10 most recent tagged images
- Delete untagged images after 1 day
- Prevents unbounded storage costs

---

## 5. IAM roles and policies

**Shared utility:** `src/shared/lambda-role.ts`

```typescript
import * as iam from 'aws-cdk-lib/aws-iam';

export const createLambdaExecutionRole = (
	scope: Construct,
	id: string,
	roleName: string
): iam.Role => {
	return new iam.Role(scope, id, {
		roleName,
		assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com'),
		managedPolicies: [
			iam.ManagedPolicy.fromAwsManagedPolicyName('service-role/AWSLambdaBasicExecutionRole')
		]
	});
};
```

**Adding permissions:**

```typescript
// In ChefLambda constructor
const lambdaRole = createLambdaExecutionRole(this, 'ChefRole', 'ChefLambdaExecutionRole');

// DynamoDB permissions
lambdaRole.addToPolicy(new iam.PolicyStatement({
	actions: [
		'dynamodb:GetItem',
		'dynamodb:PutItem',
		'dynamodb:UpdateItem',
		'dynamodb:DeleteItem',
		'dynamodb:Query',
		'dynamodb:Scan'
	],
	resources: [
		`arn:aws:dynamodb:${cdk.Aws.REGION}:${cdk.Aws.ACCOUNT_ID}:table/${props.dynamoCookbooksTable}`
	]
}));

// S3 permissions
lambdaRole.addToPolicy(new iam.PolicyStatement({
	actions: [
		's3:GetObject',
		's3:PutObject',
		's3:DeleteObject',
		's3:ListBucket'
	],
	resources: [
		`arn:aws:s3:::${props.s3CookbooksBucket}`,
		`arn:aws:s3:::${props.s3CookbooksBucket}/*`
	]
}));

this.function = new lambda.DockerImageFunction(this, 'ChefFunction', {
	// ... other props
	role: lambdaRole
});
```

**Least-privilege principles:**
- Specific actions only (no wildcards)
- Resource ARNs scoped to specific tables/buckets
- No inline wildcard policies

---

## 6. CloudWatch Logs

```typescript
import * as logs from 'aws-cdk-lib/aws-logs';

const logGroup = new logs.LogGroup(this, 'ChefLogs', {
	logGroupName: `/aws/lambda/chef`,
	retention: logs.RetentionDays.ONE_WEEK,
	removalPolicy: cdk.RemovalPolicy.DESTROY
});

this.function = new lambda.DockerImageFunction(this, 'ChefFunction', {
	// ... other props
	logGroup
});
```

---

## 7. Quick reference

### Container Lambda

```typescript
new lambda.DockerImageFunction(this, 'Function', {
	functionName: 'name',
	code: lambda.DockerImageCode.fromEcr(repo, { tagOrDigest: digest }),
	memorySize: 512,
	timeout: cdk.Duration.seconds(30),
	environment: { KEY: 'value' },
	role: lambdaRole
});
```

### API Gateway route

```typescript
new apigwv2.HttpRoute(this, 'Route', {
	httpApi: api,
	routeKey: apigwv2.HttpRouteKey.with('/path', apigwv2.HttpMethod.GET),
	integration: new HttpLambdaIntegration('Integration', fn)
});
```

### ECR repository

```typescript
new ecr.Repository(this, 'Repo', {
	repositoryName: 'name',
	imageScanOnPush: false,
	removalPolicy: cdk.RemovalPolicy.DESTROY,
	lifecycleRules: [{ maxImageCount: 10 }]
});
```

### IAM role

```typescript
new iam.Role(this, 'Role', {
	roleName: 'name',
	assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com'),
	managedPolicies: [
		iam.ManagedPolicy.fromAwsManagedPolicyName('service-role/AWSLambdaBasicExecutionRole')
	]
});
```

---

Related skills: `cdk-development-guidelines`, `cicd-guidelines`, `testing-guidelines`

Last updated: 2025-11-21
